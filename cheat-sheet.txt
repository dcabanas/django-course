pip install django -> installs django
django-admin startproject "projectname" -> starts a new project
python manage.py runserver -> starts the server and launches website
python manage.py help -> all the commands possible in Django
python manage.py startapp "appname" -> can exist multiple apps and this starts a new one, and
everytime we create a new app, it should be registered in the settings.py
pip install Pillow -> needed when using ImageField on our models
1ยบ python manage.py makemigrations -> makes the system awared off of our migrations
2ยบ python manage.py migrate -> applies the migrations to the DB
python manage.py createsuperuser -> starts the process to create a user and password for
admin page
python manage.py changepassword "nameofauser" -> changes the password of specified user
pip install djangorestframework -> installs the REST framework for Django


Theory:

class Dog:
   
   def __init__(self, name='', age=0, furcolour=''):
      self.name = name
      self.age = age
      self.furcolour = furcolour

   def bark(self, str):
      print(f'BARK {str}')


mydog = Dog()
mydog.bark('pepi')

"self" is always needed in classes

--------------------------------------------------------------------------------------------

manage.py file shouldn't be edited by us; __init__.py is for advance features when we want
to launch our webiste with initial stuff; asgi.py and wsgi.py are only used when deploying
our website; urls.py where our routes are registered

settings.py is the most important file generated by django-admin startproject command ->
DEBUG should always be set to True; INSTALLED_APPS to register our different apps;
MIDDLEWARE to register middleware; ROOT_URLCONF points to the urls.py file; 
TEMPLATES to configure the way the pages are presented; DATABASES to configure the DB we want 
to use; PASSWORD_VALIDATORS to set rules for generating password for the users

Our views can't return simple strings, must always return an HttpResponse(message) and
must always receive an 'request' arg. Or it can return a render(request, ourtemplatehtml)

when creating Models, our classes must always receive (models.Model); anytime we change or do
something new to our Models this will originate migrations, hence, these migrations need to
migrate to the DB; if we want to discard any migration(s) simply go to "migrations" folder and
delete the generated file; functions created inside our classes wont be considered as
migrations, only the properties

each app has a "admin" file -> here we register our models to be accessible through the
admin page

to grab our models from the DB so they can be displayed in the views.py -> ourmodel.objects.all()
and always use the dictionary {key: whatwewantotinjectinHTML}, as a third arg in render()

anytime we just want to inject something to be displayed in HTML we use "{{variable}}"; when
we want to do some kind of logic in HTML we use "{% code %}"

in our models when same parameter is not mandatory for the initial creation of the model,
we specify it with "blank" or null -> only blank for string/text and null+blank for the rest.
This "blank" arg is more for the admin creation page

we can pass an instance of a model to a Django form and the form will be filled with
the information

for APIs we use the Django REST framework -> needs to be added to apps in settings.py

serializers are the intermediary between the API and our backend, so the models in the DB
can be transformed to JSON and vice-versa; we need to create a serializer for each model

The REST Django framework works best with class-based views; For better understanding check
the restapi_tutorial project

When creating our own serializers these can inherit from the Abstract class Serializer or from
the ModelSerializer class, the first we need to implement the update and create methods; 
ModelSerializer allows us to not repeat the code from our model and we can specify Meta data
to our serializer, and we dont need to implement the create e update methods

the @csrf_exempt decorator is only useful when testing (in views.py) our api for POSTS, 
normally we add the { % csrf_token % } in our templates.html. And it is used if we are using
funcion-based views

@api_view() decorator allows us to see the Django REST framework UI; when changing from the
@csrf_exempt to @api_view() the Json stuff disappears

Django REST framework trully shines when using class-based views and is the preffered pattern

Generic Views + Mixins provide API behaviour for the CRUD most common operations; if the
Generic Views dont suit our API we can always go back to the Api View approach

Generics Views allow to reuse code and we always need to instantiate the two properties ->
serializer_class and queryset

when using Token Authentication we need to install it in settings.py (rest_framework.authtoken)
and after that we gotta migrate

When using ViewSet we need to specify and create all the inhereted methods; list() and retrieve()
get all or one object respectively


mixins.UpdateModel and mixins.RetrieveModel must always be used together


